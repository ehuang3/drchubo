#include <math.h>
#include <cmath>
#include <ros/ros.h>
#include <ros/subscribe_options.h>
#include <boost/thread.hpp>
#include <boost/algorithm/string.hpp>
#include <sensor_msgs/JointState.h>
#include <osrf_msgs/JointCommands.h>
#include <eigen3/Eigen/Dense>
#include "atlasKin.h"

using namespace Eigen;


void transforms(float q[]){

  lleg.trans.resize(24,4);
  rleg.trans.resize(24,4);
  larm.trans.resize(24,4);
  rarm.trans.resize(24,4);

  // Define homogeneous transformation matrices for the left leg  
  lleg.trans << -sin(q[4]), -cos(q[4]), 0, 0, cos(q[4]) ,  -sin(q[4]), 0, 0.089, 0,  0, 1, 0, 0,0, 0, 1,
    cos(q[5]), -sin(q[5]),0, 0,0, 0, -1, 0, sin(q[5]), cos(q[5]), 0, 0, 0, 0, 0, 1,
    0, 0, 1, 0, -cos(q[6]), sin(q[6]),0, -0.05,-sin(q[6]), -cos(q[6]), 0, -0.05, 0, 0, 0,1,
    cos(q[7]), -sin(q[7]), 0, 0.374, sin(q[7]),  cos(q[7]), 0,   -0.05, 0,0, 1,0,0,0, 0, 1,
    cos(q[8]), -sin(q[8]), 0, 0.422, sin(q[8]),  cos(q[8]), 0, 0,0, 0, 1, 0,0, 0, 0, 1,
    cos(q[9]), -sin(q[9]),0, 0,0, 0, -1, 0,sin(q[9]), cos(q[9]),0, 0,0, 0,  0, 1;
  lleg.counterStart =4;
  lleg.counterStop = 10;
  lleg.name = 1;

  // Define homogeneous transformation matrices for the right leg  
  rleg.trans << -sin(q[10]), -cos(q[10]), 0, 0, cos(q[10]) ,  -sin(q[10]), 0, -0.089, 0,  0, 1, 0, 0,0, 0, 1,
    cos(q[11]), -sin(q[11]),0, 0,0, 0, -1, 0, sin(q[11]), cos(q[11]), 0, 0, 0, 0, 0, 1,
    0, 0, 1, 0, -cos(q[12]), sin(q[12]),0, -0.05,-sin(q[12]), -cos(q[12]), 0, -0.05, 0, 0, 0,1,
    cos(q[13]), -sin(q[13]), 0, 0.374, sin(q[13]),  cos(q[13]), 0,   -0.05, 0,0, 1,0,0,0, 0, 1,
    cos(q[14]), -sin(q[14]), 0, 0.422, sin(q[14]),  cos(q[14]), 0, 0,0, 0, 1, 0,0, 0, 0, 1,
    cos(q[15]), -sin(q[15]),0, 0,0, 0, -1, 0,sin(q[15]), cos(q[15]),0, 0,0, 0,  0, 1;
  rleg.counterStart = 10;
  rleg.counterStop = 16;
  rleg.name = 2;

  // Define homogeneous transformation matrices for the left arm
  larm.trans << cos(q[16]),-sin(q[16]), 0, 0,0.866*sin(q[16]), 0.866*cos(q[16]), -0.5, 0,0.5*sin(q[16]), 0.5*cos(q[16]),  0.866, 0, 0,0,0, 1,
    0,0, 1,0,0.866*cos(q[17]) + 0.5*sin(q[17]), 0.5*cos(q[17]) - 0.866*sin(q[17]),0,0.0830,0.866*sin(q[17]) - 0.5*cos(q[17]), 0.866*cos(q[17]) + 0.5*sin(q[17]), 0,     -0.0063,0,0, 0,1,
    0,0, 1,0.1850,sin(q[18]), cos(q[18]),0,0,-cos(q[18]), sin(q[18]), 0,0,0,0, 0,1,
    0,0, -1,0,sin(q[19]),cos(q[19]), 0,0.013,cos(q[19]), -sin(q[19]),0, 0.121,0,0, 0,1,
    0,0,1,0.188,sin(q[20]), cos(q[20]), 0, -0.013,-cos(q[20]), sin(q[20]), 0,0,0,0,0,1,
    0,0, -1,0,sin(q[21]),cos(q[21]), 0,0,cos(q[21]),-sin(q[21]), 0, 0.0580,0,0, 0, 1; 
  larm.counterStart = 16;
  larm.counterStop = 22;
  larm.name = 3;
  // Define homogeneous transformation matrices for the right arm
  // Due to unconventional notation, this is probably wrong
 rarm.trans << cos(q[22]), -sin(q[22]),0, 0,0.866*sin(q[22]), 0.866*cos(q[22]), -0.5, 0,0.51*sin(q[22]), 0.5*cos(q[22]), 0.866, 0,0,0, 0, 1,
0, 0, 1, 0,-0.866*cos(q[23]) - 0.5*sin(q[23]),   0.866*sin(q[23]) - 0.5*cos(q[23]), 0, -0.0470,0.5*cos(q[23]) - 0.866*sin(q[23]), - 0.866*cos(q[23]) - 0.5*sin(q[23]), 0,  0.0687,0, 0, 0, 1,
0,0, -1, 0.1850,sin(q[24]),  cos(q[24]),  0, 0,cos(q[24]), -sin(q[24]),  0, 0,0, 0, 0, 1,
0,0, 1,0,sin(q[25]), cos(q[25]), 0,  -0.013,-cos(q[25]), sin(q[25]), 0, -0.121,0, 0, 0,1,
0,0, -1, 47/250,sin(q[26]),  cos(q[26]),  0, 0.013,cos(q[26]), -sin(q[26]), 0, 0,0, 0, 0, 1,
0, 0, 1, 0,sin(q[27]), cos(q[27]), 0, 0,-cos(q[27]), sin(q[27]), 0, -0.0580,0, 0, 0, 1;
  rarm.counterStart = 22;
  rarm.counterStop = 28;
  rarm.name = 4;
}

  void atlasKin::jacobian(float q[]){

    transforms(q);

    MatrixXf temp(4,4);
    temp << MatrixXf::Identity(4,4);
    J.resize(6,6);


    fk.resize(4,4);
    fk << MatrixXf::Identity(4,4);

    MatrixXf temp2(4,4);
    MatrixXf temp3(4,4);
    MatrixXf temp4(4,4);
    for (int i=0;i<6;i++){
      fk = fk*trans.block<4,4>(4*i,0);
      for (int j=i+1;j<6;j++){
         temp = temp*trans.block<4,4>(4*j,0);
      }
      temp2 = fk;
      temp2.block<3,1>(0,3) << 0,0,0;
      temp3  << MatrixXf::Identity(4,4);
      temp3.block<3,1>(0,3) = -temp.block<3,1>(0,3);
      temp4 = temp2*temp3;
      J.block<3,1>(0,i) << temp4.block<3,1>(0,3).cross(fk.block<3,1>(0,2));
      J.block<3,1>(3,i) << fk.block<3,1>(0,2);
      temp << MatrixXf::Identity(4,4);
    }
   // return J;
  }

/*~~~~~~~~~~~~~~~~~~~~~~Step Define Function~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void atlasKin::stepDefine(float q[]){

  jacobian(q);

  currentPose.resize(6);
  currentPose.segment<3>(0) = fk.block<3,1>(0,3);
  currentPose.segment<3>(3) = fk.block<3,1>(0,2);

  goal.block<3,1>(0,0)=goalPose.segment<3>(0) - currentPose.segment<3>(0);
  step << (0.001/goal.block<3,1>(0,0).norm())*goal;
  if (goal.block<3,1>(0,0).norm() == 0)
    step << 0, 0, 0,0,0,0;

}

void atlasKin::calcAndMove(float current[]){

    delQ = J.inverse()*step;
    printf("Current: ");
    //for (int i = counterStart;i<counterStop;i++)
    for (int i = 0; i<28; i++)
      printf("%f ",current[i]);
    printf("\n");
     // Correct for rotations larger than 180 degrees
    for (int s =0; s <6;s++){
      while(delQ(s) > 3.1416)
        delQ(s) = delQ(s)-3.1416;
      while(delQ(s) < -3.1416)
        delQ(s) = delQ(s)+3.1416;
    }

    // Output the current and goal poses


   // std::cout << " Joints:\t" << delQ.transpose() << std::endl;
    std::cout << "Current:\t" << currentPose.transpose() << std::endl;
    std::cout << "   Goal:\t" << goalPose.transpose() << std::endl;
    printf("Command: ");
    for (int q = 0;q<counterStart;q++){//TODO this is just temporary to hold body fixed
      jointcommands.position[q] = 0;//current[q];
      printf("%f ",jointcommands.position[q]);
    }
    for (int q = counterStart;q<counterStop;q++){
      if (delQ[q-counterStart] != delQ[q-counterStart]){
        delQ[q-counterStart] = 0.05;
      }
      // Add the differential joint position to the current position for the relevant joints
      jointcommands.position[q] = current[q]+delQ[q-counterStart];
      printf("%f ",jointcommands.position[q]);
    }
    for (int q =counterStop;q<28;q++){
      jointcommands.position[q]=0;
      printf("%f ",jointcommands.position[q]);
    }
    printf("\n\n");
    pub_joint_commands_.publish(jointcommands);
//FIXME printf("%f\n",current[17]);
//printf("FUCK\n");
}

