void trajectory (){
  // Define 4 goals;  
  VectorXf goal(24); //This probably needs to be 24
  goal << 0.2,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;

  // Divide into steps
  VectorXf step(24);
  step.block<6,1>(0,0) << (0.002/step.block<3,1>(0,0).norm())*step.block<6,1>(0,0);
  step.block<6,1>(6,0) << (0.002/step.block<3,1>(6,0).norm())*step.block<6,1>(6,0);
  step.block<6,1>(12,0) << (0.002/step.block<3,1>(12,0).norm())*step.block<6,1>(12,0);
  step.block<6,1>(18,0) << (0.002/step.block<3,1>(18,0).norm())*step.block<6,1>(18,0);

  // Update array of current angles
  ros::spinOnce();

  // calculate current pose
  VectorXf currentPose(24);
  currentPose = fk(current);

  goalPose = current pose + goal
   while (abs(goalPose-currentPose) > abs(step)){//this is wrong, do this better
    // calculate jacobian for each limb
     VectorXf llegJ(6);
     VectorXf rlegJ(6);
     VectorXf larmJ(6);
     VectorXf rarmJ(6);

    llegJ = lleg.jacobian();
    rlegJ = rleg.jacobian();
    larmJ =larm.jacobian();
    rarmJ = rarm.jacobian();

    // delQ = inverse jacobian multiplied by step.
    VectorXf delQ(24);
    delQ.block<6,1>(0,0) = llegJ.inverse()*step.block<6,1>(0,0);
    delQ.block<6,1>(6,0) = rlegJ.inverse()*step.block<6,1>(6,0);
    delQ.block<6,1>(12,0) = larmJ.inverse()*step.block<6,1>(12,0);
    delQ.block<6,1>(18,0) = rarmJ.inverse()*step.block<6,1>(18,0);    

    static ros::Time startTime = ros::Time::now();
    // for testing round trip time
    jointcommands.header.stamp = _js->header.stamp;

    // cmd = current + delQ
    // publish commands

    // get current angles
    ros::spinOnce();

    // calculate current poses
    currentPose - fk(current);
  }
  


}

VectorXf fk(current[]){
  VectorXf currentPose(24);
  MatrixXf llegFk(4,4);
  MatrixXf rlegFk(4,4);
  MatrixXf larmFk(4,4);
  MatrixXf rarmFk(4,4);

  llegFk << MatrixXf::Identity(4,4);
  rlegFk << MatrixXf::Identity(4,4);
  larmFk << MatrixXf::Identity(4,4);
  rarmFk << MatrixXf::Identity(4,4);

  trans();

  for (int i=0;i<6;i++){
    llegFk = llegFk*lleg.trans.block<4,4>(4*i,0);
    rlegFk = rlegFk*rleg.trans.block<4,4>(4*i,0);
    larmFk = llegFk*larm.trans.block<4,4>(4*i,0);
    rarmFk = llegFk*rarm.trans.block<4,4>(4*i,0);
  }
  currentPose.block<3,1>(0,0) = llegFk.block<3,1>(3,0);
  currentPose.block<3,1>(6,0) = rlegFk.block<3,1>(3,0);
  currentPose.block<3,1>(12,0) = larmFk.block<3,1>(3,0);
  currentPose.block<3,1>(18,0) = rarmFk.block<3,1>(3,0);

return currentPose;
}
